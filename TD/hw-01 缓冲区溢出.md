## 知识点

### 程序的内存布局

程序加载到内存，操作系统会为它分配虚拟地址空间，对于一个C语言程序，它的内存由5个段组成，地址从大到小分为栈、堆、BBS段、数据段、代码段。其中，栈区和堆区是在程序运行时形成的，在程序运行中分配和释放，属于动态区域；BBS段、数据段、代码段属于静态区域，数据段和代码段在链接之后生成，BBS段在程序初始化时开辟。

- 代码段：用于存放程序的可执行代码，代码段位于程序的内存布局最底部，当堆或栈溢出时，代码段中的数据开始被覆盖。
- 数据段：用于存放程序员已初始化的静态或全局变量，例如static int a=5，数据段是程序虚拟地址空间的一部分，数据段的变量在程序运行时是可以修改的。
- BSS段：用于存放未初始化的静态或全局变量，例如static int b，所有未初始化的变量默认初始化为0。
- 堆：用于动态内存分配，这一内存区由程序员使用malloc()、calloc()、realloc()、free()等函数分配释放，若不释放可能由操作系统回收，它与数据结构中的堆不同，分配方式类似于链表。
- 栈：用于存放函数内定义的局部变量或者维护函数调用的上下文，如C语言中函数参数列表、局部变量、返回值都保存在栈中，函数调用结束之后栈帧随即销毁。

为理解不同内存段是如何被使用的，请看以下代码。
```
    char x;/*未初化的全局变量，保存在bbs段中*/
    int y=10;/*已初始化的全局变量，保存在数据段中*/
    int main(){
        long a;           /*未初始化的局部变量，存放在栈中*/
        char b[50];        /*未初始化的数组变量，在栈中开辟50字节，a为其首地址*/
        static int c;        /*未初始化的静态变量，保存在bbs段中*/
        static float d=1;    /*已初始化的静态变量，保存在数据段中*/
        char *p1;         /*p1在栈上，占用4个字节*/
        char *p2="1234";  /*p2在栈上，p2指向的内容”1234”本身放在数据段*/
        p1=(char*)malloc(10*sizeof(char));/*分配的内存区域，在堆区*/
        p1[0]='1';        /*数据’1’保存在堆中*/
        p2[1]='2';        /*数据’1’保存在堆中*/
        free(p1);        /*释放堆上的内存空间*/
        return 0;
    }
```
### 栈的内存部局与函数调用

#### 1 栈帧
当函数调用时，操作系统在栈顶为其分配一块内存空间称为栈帧。一个函数的栈帧中的数据可用ebp和esp两个寄存器访问，ebp用做栈帧指针(frame pointer)，函数中的参数和局部变量的地址访问通过“ebp+偏移值”得到，esp指向栈帧顶部，用作栈指针。栈由栈帧组成，可以认为，一个函数对应一个栈帧，当函数调用结束后，该栈帧自动从栈中移去。
#### 2 栈帧的内存布局
一个栈帧拥有以下4个关键区域：参数、返回地址、前帧指针和局部变量4个关键区域，如图所示。
 ![栈帧布局](https://images.gitee.com/uploads/images/2021/0308/133438_0aed8ca4_726203.png "2.png")
- 参数：用于保存传递给函数的参数。
- 返回地址：当函数A调用函数B结束之后，需要返回到函数A继续执行，继续执行的指令为函数调用指令的下一条指令，因此需要将下一条指令的地址压入栈中。
- 前帧指针：存放上一个栈帧的指针。
- 局部变量：用于存放函数的局部变量。
下面通过一个例子观察帧指针的使用情况。
```
    int func(int a,int b)
    {
	int x;
	x=a+b;
	return x;
    }
    int main()
    {
	int result;
        result=func(1,2);
	return 0;
    }
```
编译文件，运行gdb，查看func()函数的汇编代码如下：
 ![汇编代码](https://images.gitee.com/uploads/images/2021/0308/133258_fe9046b7_726203.png "3.png")
当函数被调用时，被调函数的参数入栈，并且参数是从右至左逆序压入栈中的。以逆序的方式压入栈中是因为C语言支持可变长参数，此外栈是从高端地址向低端地址增长的，从相对栈帧的偏移值角度看，后面的参数先入栈，其偏移值大，在阅读汇编代码时可更加方便。
在上述代码中，先把前帧指针压入栈中，再将ebp指向栈顶，即新的栈帧，再给func()分配16字节栈空间。eax和edx是两个通用寄存器，用于存放临时计算的结果。分别将地址为ebp+8即1的值存入edx；将地址为ebp+12即2的值存入eax。将eax和edx的值相加存入eax，将计算的结果x存入地址为ebp-4的位置。因此，通过帧指针及编译阶段确定的偏移值，就能够找到所有变量的地址。

### 栈的缓冲区溢出

栈的缓冲区溢出是在将数据读入栈的过程中，栈为读入的数据预先分配的内存空间不足，导致溢出错误，损毁缓冲区以外的数据，从而使程序崩溃。但如果通过精心构造输入数据，可以让程序执行攻击者的恶意指令。
#### 1 C语言中用于复制数据的函数
用于数据复制的函数主要包括：strcpy()、strcat()、memcpy()等。strcpy()函数遇到字符’\0’即停止复制。与strcpy()函数相比，memcpy()函数并不是遇到'\0'就结束，而是一定会拷贝完n个字节。strcat()函数把src所指字符串添加到dest结尾处(覆盖dest结尾处的'\0')。
#### 2 缓冲区溢出
以下面代码为例进行说明：
```
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>

    void foo(char *str)
    {
        char buffer[10];
        strcpy(buffer, str);
    }

    int main(int argc, char **argv)
    {
        char str[517];
        read(STDIN_FILENO,str,517);
        func(str);
        printf("Returned Properly\n");
        return 0;
    }
```

上述代码的栈布局的如下图所示。
![输入图片说明](https://images.gitee.com/uploads/images/2021/0308/133924_eeecb32f_726203.png "1.png")
上面程序用read()函数可从标准输入中读取517字节到str字符串数组中，而foo()函数中的buffer数组只有10字节，str复制字符串到缓冲区buffer数组，由于原字符串长度大于10字节，strcpy()函数将覆盖buffer区域以外的部分内存，这就是所谓有缓冲区溢出。
虽然栈是从高地址到低地址增长，但缓冲区中的数据依然是从低地址向高地址增长。buffer数组之上包含一些关键数据，如前帧指针和返回地址。当缓冲区溢出修改了返回地址后，它将转跳到一个新的地址，这可能导致以下4种情况发生。
- 新地址并没有映射到任何物理地址，跳转失败，程序崩溃。
- 新地址映射到了某个物理地址，但该物理地址是受保护的空间（如内核地址），跳转失败，程序崩溃。
- 新地址映射到某个物理地址，但该地址不是有效的机器指令（可能是数据区），跳转失败，程序崩溃。
- 新地址中存放的是有效的机器指令，程序的执行逻辑被改变。

### 常见软件保护机制

#### 1 DEP
DEP(数据执行保护，Data Execution Prevention)基本原理是将数据所在页面标识设置为不可执行，确保不同时具有写权限和执行权限。在x86体系结构中，这个标识称为NX属性标记，位于页面表的最后一位，当标识设置为1时，页面为不可执行，当程序尝试在页面上执行时，cpu会抛出异常；标识设置为0时表示页面可以执行。在linux系统中NX设置通过int mprotect(void *addr,size_t len,int prot)系统调用实现。

#### 2 canary保护
canary保护机制通过在返回地址与缓冲区之间添加一个“哨兵”（随机数），检测“哨兵”是否被修改来判断是否发生了缓冲区溢出，随机数是根据本机周围环境的噪声信息利用SHA、MD5等哈希算法产生的。为了使canary无法被修改，可将其放在与栈物理隔离的GS段中。在32位x86体系结构中，gcc在编译程序时将生成的随机数保存在GS段偏离20的位置；在64位x86体系结构中，gcc把随机数保存在GS段偏离 40的位置。在程序执行时，canary被程序加载器加载到栈中。canary一般至少包含一个终结符，其中终结符NULL(0x00)会使strcpy()、strncpy()、stpcpy()、strcat()等函数结束复制，从而防止返回地址被覆盖。在x86体系结构中，由相同程序创建的不同线程栈中“哨兵”的值是相同的。canary在栈中的位置如图所示：
![canary](https://images.gitee.com/uploads/images/2021/0308/145347_64dfe34f_726203.png "5.png")

#### 3 ASLR
ASLR(address space layout randomization，地址空间随机化)，对内存中一些关键的数据区域（栈、堆、库等）地址进行随机化，即对关键区域的起始地址加上随机偏移量来打乱布局，让攻击者难以猜测关键数据或代码在内存中的位置。ASLR的安全性随着地址空间的位数增加而提高，可以用熵来衡量地址空间的随机程度。如果地址空间有n bit，则在该系统上基地址有2^n种可能性。对于32位linux系统而言，地址空间仅仅给地址随机化留下了很少的空间，栈可用熵为19bit，堆为13bit，当可用的熵不大时可以对ASLR进行暴力破解。此外，还可以通过泄漏一些关键函数在内存中的位置，进一步确定目标代码的位置来绕过ASLR。
ASLR有三个级别，分别是0、1、2。0表示不开启任何随机化；1表示开启对栈、堆、库的随机化；2表示在1的基础上增加对代码段的随机化(PIE：Position-Independent Executable，即"位置无关可执行程序"，它是完全由位置无关代码所组成的可执行二进制文件，当程序加载时，所有PIE二进制文件以及它所有的依赖都会加载到虚拟内存空间中的随机地址)。

### 漏洞利用工具

#### pwntools
pwntools是一个使用python语言开发的漏洞利用框架，可简化漏洞利用过程。更多细节可以从[这里](https://pwntoolsdocinzh-cn.readthedocs.io/en/master/intro.html)了解，以下是一个示例。
```python
    #!/usr/bin/python
    from pwn import *
    r = remote('ip address', 31337)
    r.sendline('111')
    r.recvuntil('aaa')
    payload = "A"*10
    r.send(payload)
    r.interactive()
  ```
#### nc工具
nc(netcat)是一个功能强大的网络工具，使用`nc <ip地址> <端口号>`可连接到指定ip地址的相应端口，配合linux系统中的管道命令`"|"`或重定向符`"<"`、`"<<"`、`">"`和`">>"`可实现客户端与服务器之间的数据交互。

## 作业

#### 1 实验说明
本次作业包括三个实验，在每个实验中部署了一个运行在远程服务器的程序（服务器的IP地址为：47.99.80.189），程序的源码和二进制文件在gitee中已提供，为了降低难度，所有程序的软件保护机制均已关闭。你需要找到程序的漏洞，通过利用漏洞获取shell并执行当前目录下的flag.exe程序(执行flag.exe时需要加上自己的学号)，会得到一个包含时间戳的输出。你可以使用pwntools或nc工具与服务器进行交互。

- 下图是使用pwntools与服务器交互的结果。
![实验结果1](https://images.gitee.com/uploads/images/2021/0308/101727_abe59c45_726203.png "result.png")

- 下图是使用nc工具与服务器交互的结果。
![实验结果2](https://images.gitee.com/uploads/images/2021/0308/115336_0f65ce36_726203.png "result2.png")

#### 2 实验要求
- 需在报告中说明漏洞利用思路和方法，关键分析步骤及结果需要截图记录。
- 实验完成之后，将实验报告和代码在“学在浙大”提交。
- DDL: **4月07日 23:59**

#### 3 实验内容
-  **实验 1. Buffer Overflow Baby**  [30 分]
在本实验中，给定了程序源代码以及编译好的binary；你需要通过缓冲区溢出覆盖程序的局部变量，绕过检查获取shell，执行目标机器上的flag.exe进行证明。
请连接服务器的10001端口完成此题。

-  **实验 2. Buffer Overflow Boy**  [30 分]
在本实验中，你需要通过缓冲区溢出覆盖程序的返回地址，跳转至目的函数获取shell，执行目标机器上的flag.exe进行证明。
请连接服务器的10002端口完成此题。

-  **实验 3. Buffer Overflow Again**  [40 分]
在本实验中，你需要通过缓冲区溢出覆盖程序的返回地址，并跳转至带有参数的目的函数获取shell，执行目标机器上的flag.exe进行证明。
请连接服务器的10003端口完成此题。

## 参考资料

- https://www.cnblogs.com/clover-toeic/p/3755401.html
- https://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/
- https://seedsecuritylabs.org/Labs_16.04/PDF/Buffer_Overflow.pdf
- https://pwntoolsdocinzh-cn.readthedocs.io/en/master/intro.html
